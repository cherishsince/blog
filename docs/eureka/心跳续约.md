# 心跳续约



## EurekaClient 心跳续约





## EurekaServer 心跳续约



```java
@PUT
public Response renewLease(
        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,
        @QueryParam("overriddenstatus") String overriddenStatus,
        @QueryParam("status") String status,
        @QueryParam("lastDirtyTimestamp") String lastDirtyTimestamp) {
    // <1> isReplication 标记是否是复制(集群节点复制的时候为 true)
    // tip: 用户心跳续约这个为 false，然后会调用集群同步为true的时候，为true的时候就不会去同步到其他节点去
    boolean isFromReplicaNode = "true".equals(isReplication);
    // <2> 调用心跳续约
    boolean isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);

    // Not found in the registry, immediately ask for a register
    if (!isSuccess) {
        logger.warn("Not Found (Renew): {} - {}", app.getName(), id);
        return Response.status(Status.NOT_FOUND).build();
    }
    // Check if we need to sync based on dirty time stamp, the client
    // instance might have changed some value
    Response response;
    if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
        response = this.validateDirtyTimestamp(Long.valueOf(lastDirtyTimestamp), isFromReplicaNode);
        // Store the overridden status since the validation found out the node that replicates wins
        if (response.getStatus() == Response.Status.NOT_FOUND.getStatusCode()
                && (overriddenStatus != null)
                && !(InstanceStatus.UNKNOWN.name().equals(overriddenStatus))
                && isFromReplicaNode) {
            registry.storeOverriddenStatusIfRequired(app.getAppName(), id, InstanceStatus.valueOf(overriddenStatus));
        }
    } else {
        // <3> 续约成功
        response = Response.ok().build();
    }
    logger.debug("Found (Renew): {} - {}; reply status={}", app.getName(), id, response.getStatus());
    return response;
}
```

说明：

- <1> 用户心跳续约这个为 false，然后会调用集群同步为true的时候，为true的时候就不会去同步到其他节点去。
- <2> 调用心跳续约，成功返回 true，失败为 false。



##### 心跳续约 registry.renew()

```java
// PeerAwareInstanceRegistryImpl
public boolean renew(final String appName, final String id, final boolean isReplication) {
    // 执行心跳续约
    if (super.renew(appName, id, isReplication)) {
        // 复制到其他节点
        replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);
        return true;
    }
    return false;
}
```

说明：

- `PeerAwareInstanceRegistryImpl` 里面的 `renew` 是提供了集群的动作。
- 执行 **心跳续约** 成功后，会将信息复制到其他节点去。



##### 心跳续约 super.renew()



```java
// AbstractInstanceRegistry

// 注册的实例
private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry
            = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();

public boolean renew(String appName, String id, boolean isReplication) {
    // 续约次数 +1
    RENEW.increment(isReplication);
    // 根据 appName 获取注册的实例节点信息
    Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);

    // 获取续约的节点
    Lease<InstanceInfo> leaseToRenew = null;
    if (gMap != null) {
        leaseToRenew = gMap.get(id);
    }
    // <1>
    // tip: 没有找到续约的节点，这里会返回一个 NOT_FOUND
    // tip: client 收到 NOT_FOUND，会去调用register进行注册
    if (leaseToRenew == null) {
        RENEW_NOT_FOUND.increment(isReplication);
        logger.warn("DS: Registry: lease doesn't exist, registering resource: {} - {}", appName, id);
        return false;
    } else {
        // tip: 心跳续约

        // tip: getHolder 保存的是我们 client 注册的 InstanceInfo
        InstanceInfo instanceInfo = leaseToRenew.getHolder();
        if (instanceInfo != null) {
            // touchASGCache(instanceInfo.getASGName());
            // 获取覆盖实例状态(这一步)
            InstanceStatus overriddenInstanceStatus = this.getOverriddenInstanceStatus(
                    instanceInfo, leaseToRenew, isReplication);
            // UNKNOWN 是一个未知的状态
            if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                        + "; re-register required", instanceInfo.getId());
                RENEW_NOT_FOUND.increment(isReplication);
                return false;
            }
            if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                logger.info(
                        "The instance status {} is different from overridden instance status {} for instance {}. "
                                + "Hence setting the status to overridden status", instanceInfo.getStatus().name(),
                        overriddenInstanceStatus.name(),
                        instanceInfo.getId());
                instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);
            }
        }
        // <2> 续租每分钟次数 +1
        renewsLastMin.increment();
        // <3> 设置 租约最后更新时间（续租）
        leaseToRenew.renew();
        return true;
    }
}
```

说明：

- `register` 是一个 ConcurrentMap 保存的是，实例注册的信息。

- 就是根据 **appName** 获取，注册的实例信息，然后调用 `leaseToRenew.renew()` 更新过期时间。
- 注意：根据 **appName** 没有获取到注册的实例信息(`leaseToRenew == null`) 的时候，会返回一个 `NOT_FOUND`，客户端接收到会调用 register 重新注册。

- `renewsLastMin` 这个比较重要，是一个统计数据：
  - EurekaServer 运维界面的显示**续租每分钟次数**。
  - EurekaServer 的自我保护机制。

- <3> 是一个**续约** 更新一下最后更新时间 = 当前时间 + 续约时间(Eureka 里面用到了大量的 Timer，定时处理，比如服务剔除，也只是标记一下过期时间)。

  ```java
  // Lease
  public void renew() {
      lastUpdateTimestamp = System.currentTimeMillis() + duration;
  }
  ```

  

> 心跳续约，知识更新了过期时间，因为Eureka 采用的 Timer会定时检查过期时间，过期了就会剔除；注意：如果开启了 **自我保护** 那么就不会立即剔除，而是需要一段时间。



完结~